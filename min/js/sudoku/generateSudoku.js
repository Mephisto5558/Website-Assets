let MAX_FULL_RETRIES=100,CONSECUTIVE_RETRY_COOLDOWN_MS=5,DEBUG_BOARDS={board:[[6,5,8,4,2,0,0,0,0],[0,2,3,7,0,0,4,0,0],[4,1,7,6,0,9,0,0,5],[0,0,6,8,0,5,7,4,2],[0,9,2,3,0,7,5,6,1],[7,4,5,1,6,2,9,0,8],[0,0,1,5,0,4,2,8,0],[0,7,0,9,8,0,0,5,0],[5,0,9,2,0,3,6,0,4]],fullBoard:[[6,5,8,4,2,1,3,9,7],[9,2,3,7,5,8,4,1,6],[4,1,7,6,3,9,8,2,5],[1,3,6,8,9,5,7,4,2],[8,9,2,3,4,7,5,6,1],[7,4,5,1,6,2,9,3,8],[3,6,1,5,7,4,2,8,9],[2,7,4,9,8,6,1,5,3],[5,8,9,2,1,3,6,7,4]]};function getNumberAmounts(e){return e.flat().reduce((e,t)=>e.set(t,(e.get(t)??0)+1),new Map)}function getEmptySudoku(e,t){return Array.from({length:e},()=>Array.from({length:e},void 0===t?void 0:()=>t))}function getNext(e,t,o){return t==o-1?[e+1,0]:[e,t+1]}async function generateSudoku(t,o,r=1){if(globalThis.debug&&globalThis.debugBoard)return DEBUG_BOARDS;var e=Math.sqrt(t);if(!Number.isInteger(e))throw new Error("Size must be quadratic.");console.debug(`Generating initial full Sudoku. Try ${r}/`+MAX_FULL_RETRIES);var n=getEmptySudoku(t);if(fill(n,e),!countSolutions(structuredClone(n),e)){let e="An invalid Sudoku has been generated. ";return globalThis.debug?e+="Returning the Sudoku due to being in debug mode.":e+=r<MAX_FULL_RETRIES?`Retrying ${r+1}/`+MAX_FULL_RETRIES:"Max retries reached. Not retrying.",console.error(e),console.error(JSON.stringify(n)),globalThis.debug?n:r<MAX_FULL_RETRIES?generateSudoku(t,o,r+1):getEmptySudoku(t,0)}var u=structuredClone(n),l=t**2*5,i=t**2,a="Sudoku has more than one possible solution. ";console.debug("Starting to dig holes. Max Attempts: "+l);let s=0,g=0,d=0;for(;s<o&&g<l&&d<i;g++){console.debug(`Digging. Holes: ${s}/${o}, Attempts: ${g}/${l}, Consecutive attempts: ${d}/`+i);var f=dig(u,e);f?(d=0,s++):void 0!==f&&(++d>i?console.debug(a+"Max consecutive attempts reached. Not retrying."):g>l?console.debug(a+"Max attempts reached. Not retrying."):(console.debug(a+`Retrying ${g+1}/${l}. Waiting 5ms`),await new Promise(e=>setTimeout(e,CONSECUTIVE_RETRY_COOLDOWN_MS))))}return console.debug(`Dug ${s}/${o} holes. Took ${g}/${l} attempts (last consecutive attempts: ${d}/${i}).`),globalThis.debug&&(console.debug("Board:",JSON.stringify(u)),console.debug("Full Board:",JSON.stringify(n))),{fullBoard:n,board:u}}function dig(e,t){var o,r=rando(0,e.length-1),n=rando(0,e.length-1);if(e[r][n])return(o=structuredClone(e))[r][n]=0,!(1<countSolutions(o,t)||(e[r][n]=0))}function fill(e,t,o=0,r=0){if(o>e.length-1)return!0;var n,[u,l]=getNext(o,r,e.length);for(n of randoSequence(1,e.length))if(!isUnsafe(e,t,o,r,n)){if(e[o][r]=n,fill(e,t,u,l))return!0;e[o][r]=0}return!1}function countSolutions(t,o,r=0,n=0){if(r>t.length-1)return 1;var[u,l]=getNext(r,n,t.length);if(t[r][n])return countSolutions(t,o,u,l);let i=0;for(let e=1;e<=t.length&&(isUnsafe(t,o,r,n,e)||(t[r][n]=e,i+=countSolutions(t,o,u,l),t[r][n]=0,!(1<i)));e++);return i}function isUnsafe(o,r,t,n,u){for(let e=0;e<o.length;e++)if(o[t][e]===u||o[e][n]===u)return!0;var e=Math.floor(t/r)*r,l=Math.floor(n/r)*r;for(let t=e;t<e+r;t++)for(let e=l;e<l+r;e++)if(o[t][e]===u)return!0;return!1}function displayBoard(e,t,o){for(var r of t.flat())r.value=e[Number(r.dataset.row)-1][Number(r.dataset.col)-1]||void 0,r.disabled=!!r.value;for(var[n,u]of getNumberAmounts(e))n&&(o[n-1].textContent=u,globalThis.fullBoardNumberAmt.get(n)==u)&&o[n-1].classList.add("complete")}export{getNumberAmounts,generateSudoku,displayBoard};